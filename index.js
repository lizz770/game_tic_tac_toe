/**
[WARNING]: This file was auto generated by @urturn/runner package.
- Do NOT edit this file: all changes to room functions should go under your "src/" folder!
- See https://docs.urturn.app for more info
- Join discord if you have questions https://discord.gg/myWacjdb5S.
*/
'use strict';

const Status = Object.freeze({
  PreGame: 'preGame',
  InGame: 'inGame',
  EndGame: 'endGame',
});

const Mark = Object.freeze({
  X: 'X',
  O: 'O',
});

/**
 * evaluateBoard() определяет, закончена ли игра в крестики-нолики, и предоставляет подробную информацию (ничья или победитель)
 * @param {string[][]} board, 2D-массив размером 3x3 с 'X' и 'O' в качестве значений
 * @param {{[string]: string}} plrIdToPlrMark, карта от plrId до метки игрока
 * @param {Player[]} players, список игроков
 * @returns {
 *  winner?: Player, (the player that won the game if they exist)
 *  tie?: bool, (true if tie, and false if not a tie)
 *  finished: bool, (true if the game is finished, and false if not finished)
 * }
 */
const evaluateBoard = (board, plrIdToPlrMark, players) => {
  /**
   * ЗАДАЧА: проверьте наличие победителя (подсказка: убедитесь, что отметка не равна нулю)
   * - проверьте строки
   * - проверьте столбцы
   * - проверьте диагонали
   */
  for(let i=0; i<3;i++){
    //проверка строк
    const mark=board[i][0];
    const isSame =board[i][1] ===mark && board[i][2] === mark;

    if(mark != null && isSame){
      const winner =players.find(player => plrIdToPlrMark[player.id] === mark);
      return {
        finished:true,
        winner
      };
    }
  }
  for(let i=0; i<3;i++){
    //проверка   столбцов
    const mark=board[0][i];
    const isSame =board[1][i] ===mark && board[2][i] === mark;

    if(mark != null && isSame){
      const winner =players.find(player => plrIdToPlrMark[player.id] === mark);
      return {
        finished:true,
        winner
      };
    }
  }

  const mark=board[1][1];
  //проверка диагоналей
  const isSameDiagl = board[0][0] === board[1][1] && board[1][1] === board[2][2];
  if(mark!= null && isSameDiagl){
    const winner =players.find(player => plrIdToPlrMark[player.id] === mark);
      return {
        finished:true,
        winner
      };
  }
  //проверка диагоналей
  const isSameDiagl2 = board[2][0] === board[1][1] && board[1][1] === board[0][2];
  if(mark!= null && isSameDiagl2){
    const winner =players.find(player => plrIdToPlrMark[player.id] === mark);
      return {
        finished:true,
        winner
      };
  }

  //ничья когда доска полность заполнена
  const isTie=board.every((row)=>row.every((mark) =>mark != null));
  if (isTie){
    return { finished: true, tie:isTie};
  }

  //возврат по умолчанию не завершен
  return {finished: false }

};

function onRoomStart() {
  /**
   * ЗАДАЧА: определите поля:
   * 
   * state.status (hint: use Status enum)
   * state.plrIdToPlrMark
   * state.plrMoveIndex
   * state.board
   * state.winner
   */
  const state = {
    status:Status.PreGame,
    //доска
    board:[
      [null, null, null],
      [null, null, null],
      [null, null, null],
    ],
    plrMoveIndex:0,
    plrIdToPlrMark:{}, //[plrId]:Mark.X
    winner:null,
  };
  return { state };
}

function onPlayerJoin(player, roomState) {
  const { players, state } = roomState;
  if (players.length === 2) { // достаточно игроков, чтобы играть в эту игру
    //измените состояние, чтобы начать игру
    state.status=Status.InGame;
    state.plrIdToPlrMark={
      [players[0].id]:Mark.X,//первый игрок крестик второй нолик
      [players[1].id]:Mark.O
    };

    return {
      //скажите вашей очереди, чтобы она больше не допускала игроков в эту комнату
      state,
      joinable:false,
    };
  }

  // все еще ждем другого игрока, поэтому не вносите никаких изменений
  return {};
}

function onPlayerMove(player, move, roomState) {
  const { state, players, logger } = roomState;
  const { plrMoveIndex, plrIdToPlrMark } = state;
  const { x, y } = move;

  // проверить ход игрока и выдать разумные сообщения об ошибках
  if(state.status !== Status.InGame){
    throw new Error('Игра не ведется, вы не можете сделать ход!')
  }
  if (players[plrMoveIndex].id !== player.id){
    throw new Error('Эй, сейчас не твоя очередь!')
  }
  if (state.board[x][y] !== null){
    throw new Error('Кто-то уже отметил эту клетку!')

  }
  // что делать, если игрок попытается сделать ход, когда игра еще не началась?
  // что делать, если игрок делает ход, а сейчас не его очередь?
  // что делать, если игрок делает ход на доске, где уже была отметка?
  
  //установка доски
  state.board[x][y] = plrIdToPlrMark[player.id];

  // проверьте, закончена ли игра
  const result = evaluateBoard(state.board, plrIdToPlrMark, players);
  if (result?.finished) {
    state.status = Status.EndGame;
    // обрабатывать различные случаи, когда игра завершена, используя значения, вычисленные из

    if(result.winner != null){
      state.winner =result.winner;
    }
    return {
      state,
      finished:true,
      // ЧТО НУЖНО СДЕЛАТЬ: включить изменения состояния, чтобы включить обновление состояния
      // ЧТО ДЕЛАТЬ: сообщите вашей очереди, что комната закончена, что позволит вам правильно отобразить комнату
    };
  }

  //Установите plr для перехода к следующему игроку (подсказка: обновить state.plrMoveIndex)
  state.plrMoveIndex =(plrMoveIndex + 1) % 2;
  return { state };
}

function onPlayerQuit(player, roomState) {
  const { state, players } = roomState;

  state.status = Status.EndGame;
  if (players.length === 1) {
    // когда игрок уходит и появляется другой игрок, мы должны по умолчанию назначить победителя
    // быть оставшимся игроком
    const [winner] = players;
    state.winner = winner;
    return {
      //скажите, что ваша очередь в комнате окончена
      state,
      finished:true,
    };
  }
  return {
    // когда игрок уходит, а другого игрока не было, победителя нет
    // правильно скажи, что твоя очередь, комната окончена
    state,
    finished:true,
    joinable:false,
  };
}

//функция комнаты
var main = {
  onRoomStart,
  onPlayerJoin,
  onPlayerMove,
  onPlayerQuit,
};

module.exports = main;
//# sourceMappingURL=index.js.map
